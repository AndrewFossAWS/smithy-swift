package software.amazon.smithy.kotlin.codegen

import software.amazon.smithy.codegen.core.CodegenException
import software.amazon.smithy.codegen.core.Symbol
import software.amazon.smithy.codegen.core.SymbolDependency
import software.amazon.smithy.codegen.core.SymbolReference
import software.amazon.smithy.utils.CodeWriter
import java.util.function.BiFunction


class KotlinWriter(private val fullPackageName: String): CodeWriter() {
    init {
        trimBlankLines()
        trimTrailingSpaces()
        setIndentText("    ")
        putFormatter('T', KotlinSymbolFormatter())
    }

    internal val dependencies: MutableList<SymbolDependency> = mutableListOf()


    fun addImport(symbol: Symbol, packageName: String, vararg options: SymbolReference.Option) {
        // always add dependencies
        dependencies.addAll(symbol.dependencies)

//        if (!symbol.namespace.isEmpty() && !symbol.namespace.equals(fullPackageName)) {
//            addImport(symbol.namespace, packageName)
//        }
    }

    fun addImportReferences(symbol: Symbol, vararg options: SymbolReference.ContextOption){
        symbol.references.forEach {reference ->
            for(option in options) {
                if (reference.hasOption(option)) {
                    addImport(reference.symbol, reference.alias, *options)
                    break
                }
            }
        }
    }

    override fun toString(): String {
        val contents = super.toString()
        val header = "// Code generated by smithy-kotlin-codegen. DO NOT EDIT!\n\n"
        return header + contents
    }

    /**
     * Configures the writer with the appropriate opening/closing doc comment lines and calls the [block]
     * with this writer. Any calls to `write()` inside of block will be escaped appropriately.
     * On return the writer's original state is restored.
     *
     * e.g.
     * ```
     * writer.dokka(){
     *     write("This is a doc comment")
     * }
     * ```
     *
     * would output
     *
     * ```
     * /**
     *  * This is a doc comment
     *  */
     * ```
     */
    fun dokka(block: KotlinWriter.() -> Unit) {
        pushState()
        write("/**")
        setNewlinePrefix("*")
        block(this)
        popState()
        write(" */")
    }

    /**
     * Implements Kotlin symbol formatting for the `$T` formatter
     */
    private class KotlinSymbolFormatter: BiFunction<Any, String, String> {
        override fun apply(type: Any, indent: String): String {
            when(type) {
                is Symbol -> {
                    var formatted = type.name
                    if (type.isBoxed()) {
                        formatted += "?"
                    }

                    val defaultValue = type.defaultValue()
                    if (defaultValue != null) {
                        formatted += " = $defaultValue"
                    }
                    return formatted
                }
//            is SymbolReference -> println("symbol ref")
                else -> throw CodegenException("Invalid type provided for \$T. Expected a Symbol, but found `$type`")
            }
        }
    }

}